#### 1. 什么是Web Server

>web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的**程序**，一个Web Server就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机），可以**处理浏览器等Web客户端的请求并返回相应响应**。

#### 2. 用户如何与Web Server通信

>通常用户是通过Web浏览器与服务器通信的。在浏览器中键入“**域名**”或者是“**IP地址:端口号**”，浏览器则将域名解析为相应的IP地址或者直接通过IP地址向对应的Web服务器发送一个HTTP请求。
>
>

#### 3. Socket

> 传统意义上是类似于文件描述符的存在形式，是一种抽象的资源定位，即进程端口资源。socket就是一个**资源标识**，是一个三元组（协议，端口号，IP地址）。
>
> 所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间**进行双向通信的端点的抽象**。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。

#### 4. I/O复用及相关

> 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向[内核](https://baike.baidu.com/item/内核)为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。
>
> 文件描述符：在linux系统中打开文件就会获得文件描述符，它是个很小的非负整数。每个进程在PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。

socket在创建的时候**默认是阻塞的**，我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。

I/O复用函数本身是阻塞的，它们能提高程序效率的原因是在于它们具有同时监听多个I/O事件的能力。 

##### 1. 事件处理模式与I/O模型

有两种高效的事件处理模式：

- **Reactor**模式：**要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写**），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。**有事件发生就通知我**

- **Proactor**模式：**将所有的I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑**，如主线程读完成后`users[sockfd].read()`，选择一个工作线程来处理客户请求`pool->append(users + sockfd)`。**等事件处理完就通知我。**

- 共有五种I/O模型：

    - 阻塞I/O：当执行IO操作指令时，当前执行的线程会被阻塞挂起，直至IO操作返回结果后，才能继续执行下一步的操作
    - 非阻塞I/O：当执行IO操作指令时，当前的线程不会被阻塞，会去执行其他操作，但会时不时的轮询IO操作结果
    - I/O复用：linux用select，poll，epoll实现IO复用模型。不同的是，这些函数可以同时阻塞多个IO操作。
    - 异步I/O：当遇到I/O操作时，先发送I/O指令，不等待返回结果，去执行其他的操作，等I/O操作已完成返回结果时，再通知当前程序继续处理。
    - 信号驱动I/O：:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。

    注意：阻塞IO，非阻塞IO，IO复用，信号驱动IO都是同步IO，

- 通常使用同步I/O模型（如`epoll_wait`）实现Reactor，使用异步I/O（如`aio_read`和`aio_write`）实现Proactor。
    
    1. **同步和异步关注的是双方的消息通信机制；阻塞和非阻塞关注的是程序在等待调用结果时的状态。**
    2. 同步阻塞I/O：在一个线程中，cpu执行速度非常快，当遇到I/O操作时，如读写操作、发送网络数据时，**就需要等待I/O操作完成，才能进行下一步操作**。
    3. 同步非阻塞I/O：此种方式下，应用发起一个I/O操作后可返回做其他事情，但需要时不时的询问I/O操作是否完成。
    4. 异步I/O：当遇到I/O操作时，先发送I/O指令，不等待返回结果，去执行其他的操作，等I/O操作已完成返回结果时，再通知cpu进行处理。

##### 2. 三种I/O复用技术：select、poll、epoll（最优）

1. 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要**将整个集合拷贝到内核态**；**epoll则将整个文件描述符集合维护在内核态**，每次添加文件描述符的时候都需要执行一个系统调用。
2. select监听的文件描述符的有限；poll，和epoll监听的文件描述符数量可以达到系统允许的最大数目。
3. 对于select和poll来说，只能支持相对低效的LT（电平触发）模式，而epoll则支持高效的ET（边沿触发）模式。
4. select和poll采用的都是轮询的方式，**即每次都会扫描整个文件描述符集合，即时间复杂度为O(n)**；而epoll采用的是回调的方式，内核检测到就绪的文件描述符时，将触发回调函数，再将对应事件插入到内核就绪队列，**时间复杂度为O(1)**。
5. epoll适用于连接数量多，但活动连接数较少的情况。连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好。

##### 3. 两种高效并发编程模式

 - 并发：让程序**“同时”执行**多个任务。实际上还是**交替执行**，由于CPU执行速度很快，会让使用者产生一种同时执行的错觉。
 - 并发模式是指I/O处理单元与多个逻辑单元之间协调完成任务的方法。
 - 在I/O模型中，**同步和异步**区分的是内核向应用程序中通知的是何种I/O事件（就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）；在并发模式中，**同步指的是程序完全按照代码序列的顺序执行**，异步指的是程序的执行需要由**系统事件来驱动**。常见系统事件包括中断、信号等。
 - 按照同步方式运行的线程称为**同步线程**，按照异步方式运行的线程称为**异步线程**。异步线程执行效率高，实时性强，但难以调试和扩展，不适合大量并发；同步线程效率较低，实时性低，但逻辑简单。

 1. 半同步/半异步模式：
     - 同步线程（相当于逻辑单元）处理客户逻辑，异步线程（I/O处理单元）用于处理I/O事件
     - 半同步半反应堆模式（变体）：主线程为异步线程，用于监听所有socket的事件，工作线程处理读读写事件。采用的事件处理模式是**Reactor模式**。
     - 半同步半反应堆模式（变体）：主线程为异步线程，有主线程来完成数据的读写，然后将应用程序数据，任务类型等信息封装为一个任务对象插入请求队列，工作线程则将之处理。这是**Proactor模式**。
     - **缺点**：
         1. 主线程和工作线程共享请求队列，对请求队列的操作需求加锁，耗费CPU时间。
         2. 每一个工作线程在同一时间只能处理一个客户请求。客户数量多，工作线程少，请求队列任务堆积，响应满，如果添加试图通过增加线程，则由于线程切换导致的CPU时间消耗。
 2. 领导者/追随者模式：
     - 由多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任何时间点，只有一个领导者线程，它负责监听IO事件。

> pthread_detach()即主线程与子线程分离，子线程结束后，**资源自动回收**。pthread_join()即是子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。

##### 4. 有限状态机

>有限状态机是逻辑单元中内部的一种高效的编程方法，在服务器编程中，服务器可以根据不同状态或者消息类型进行相应的处理逻辑，使得程序逻辑清晰易懂。
>
>**有限个状态以及在这些状态之间的转移和动作等行为的数学模型**。

1. 可以用状态来描述事物，并且任一时刻，事物总是处于一种状态；
2. 事物拥有的状态总数是有限的；
3. 通过触发事物的某些行为，可以导致事物从一种状态过渡到另一种状态；
4. 事物状态变化是有规则的，A状态可以变换到B，B可以变换到C，A却不一定能变换到C；
5. 同一种行为，可以将事物从多种状态变成同种状态，但是不能从同种状态变成多种状态。

##### getopt函数

```cpp
 //解析命令行参数的函数
 void Config::parse_arg(int argc, char*argv[]){
     int opt;
     const char *str = "p:l:m:o:s:t:c:a:";
     while ((opt = getopt(argc, argv, str)) != -1)
     {
       switch (opt)
         {
         case 'p':
         {
             PORT = atoi(optarg);//optarg指向的是参数地址
             break;
         }
     }
       
 //---------------------
      extern char *optarg;  //选项的参数指针
      extern int optind,   //下一次调用getopt的时，从optind存储的位置处重新开始检查选项。 
      extern int opterr,  //当opterr=0时，getopt不向stderr输出错误信息。
      extern int optopt;  //当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回'？’
      int getopt(int argc, char * const argv[], const char *optstring);
 /*
 	字符串optstring是下列参数，Example："p:l:m:o:s:t:c:a:"
 	1.单个字符，表示选项
 	2.单个字符后接一个冒号表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg
 	3.单个字符后跟两个冒号，表示该选项后必须跟一个参数。参数必须紧跟在选项后 不能 以空格隔开。该参数的指针赋给optarg。
 	
 	getopt处理以'-’开头的命令行参数,如 ./server -p 9007 -l 1   -p是选项 9007是参数
 
 */
```

#### 5.日志系统详解

##### 1. 单例模式

>单例模式：最常用的设计模式之一，保证一个类只有一个实例，并且提供一个全局访问点，即公有的访问函数，是静态成员函数。
>
>实现思路：
>
>1. **私有化构造函数**，防止外界创建对象。
>2. 提供一个私有静态指针指向唯一实例。
>3. 提供一个公有的静态方法。
>
>**线程安全：**在拥有**共享数据的多条线程并行执行的程序中**，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。
>
>懒汉模式：顾名思义，即比较懒，当需要的时候才去初始化，避免内存浪费。（实例的初始化放在`getinstance`函数内部）
>
>>- 经典的线程安全懒汉模式，使用双检测锁模式。
>>
>>- 可以利用局部变量实现线程安全懒汉模式。（在C++11以后，要求编译器保证**静态变量初始化**的线程安全性）
>
>饿汉模式：在程序运行时就初始化，效率高，是线程安全的，但浪费内存。（实例的初始化放在`getinstance`函数外部）。

##### 2. 同步与异步

>**同步和异步通常用来形容一次方法调用。**
>
>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。
>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。
>
>它们的**区别就在于一个需要等待，一个不需要等待**，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式，比如日志记录就可以使用异步方式进行保存。

##### 3. Linux线程库及加锁

1. 线程

    >线程是轻量级进程，线程的本质是进程（Linux下）；
    >
    >线程是操作系统调度执行的最小单位，进程是资源管理和分配的最小单位；
    >
    >进程拥有自己的独立地址空间；而线程共享一块进程地址空间；
    >
    >进程上下文切换开销较大，线程相对于较小，更加节省系统资源。
    >
    >**进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。**

2. >每一个线程都有一个唯一的线程 ID，ID 类型为 pthread_t，这个 ID 是一个无符号长整形数
    >
    >获取线程ID的函数是：**pthread_t pthread_self()**;//返回当前线程的线程ID

3. 线程同步

    >当前一个线程对内存中的**共享资源**进行访问的时候，其他线程不可以对这块内存进行访问，当前线程访问完毕之后，其他线程才可以按序对其访问。**所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。**

4. 对于多个线程访问共享资源时，需要进行线程同步。常用的线程同步方式：**互斥锁，读写锁，条件变量，信号量四种。**

    - 互斥锁：pthread_mutex_t  mutex

        - 一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。**一般情况下，每一个共享资源对应一个把互斥锁，锁的个数和线程的个数无关。**
        - 死锁：如果锁使用不当，就会造成**死锁**这种现象。如果线程死锁造成的后果是：**所有的线程都被阻塞，并且线程的阻塞是无法解开的**。导致死锁有以下场景：
            - 加锁之后忘记解锁
            - 重复加锁
            - 有多个共享资源，故有很多锁，若随意加锁，会导致阻塞

    - 读写锁

        >pthread_rwlock_t  rwlock;
        >
        >读写锁是互斥锁的升级版，读操作的时候可以提高程序执行效率，**如果线程的操作都是读操作，那么是并行的，但使用互斥锁则是串行的。**

        - 读锁是共享的，写锁是独占的，写锁优先级比读锁高。

    - 条件变量

        - 如果说互斥锁是用于同步线程**对共享数据的访问**，那么条件变量则是用于在线程之间同步**共享数据的值。**

        - 条件变量的主要作用**不是实现线程同步，而是线程阻塞。**

        - 一般情况下，条件变量用于处理生产者和消费者模型，并且配合互斥锁使用。
    
            >pthread_cond_t cond;  创建一个条件变量类型的变量
            >
            >pthread_cond_signa;l 唤醒至少一个被阻塞的线程
        >
            >pthread_cond_broadcast; 唤醒所有被阻塞的线程

        - 生产者和消费者模型，有三种工作角色
    
            - 生产者线程：若干个，缓冲区满时则，则阻塞
        - 消费者线程：若干个，缓冲区为空时，则阻塞
            - 缓冲区：**为了读写访问可以通过一个数据结构维护这块内存**，可以是队列，链表，数组等等

    - 信号量

        - 信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。

        - 信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为 sem_t 对应的头文件为 <semaphore.h>
    
            >#include <semaphore.h>
            >sem_t sem;
            >
            >//sem:信号量变量
            >
            >//pshared: 0->表示线程同步  非0表示进程同步
            >
            >//value: 初始化当前信号量拥有的资源数（>0），等于0表示线程会被阻塞
        >
            >int sem_init(sem_t *sem, int pshared, unsigned int value);
    
        - >//在总资源数大于1的多线程多任务中  这两行代码顺序不能改变  否则会造成死锁
            >
            >sem_wait(&sem)
            >
            >Pthread_mutex_lock(&mutex)

##### 4. C++线程库

1. 当启动了一个线程（创建了一个 thread 对象）之后，在这个线程结束的时候（std::terminate ()），我们如何去回收线程所使用的资源呢？thread 库给我们两种选择：

    - join() 加入式
    - detach()分离式

2. join

    - 在某个线程中通过子线程对象调用 join() 函数，**调用这个函数的线程被阻塞**，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后 join() 会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。
    - **函数在哪个线程中被执行，那么函数就阻塞哪个线程。**例如在主线程中调用则阻塞主线程，等待至子线程完成，才开始继续进行主线程

3. detach

    - detach() 函数的作用是进行线程分离，分离主线程和创建出的子线程。
    - 在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，**在主线程退出之前，它可以脱离主线程继续独立的运行**，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。
    - **线程分离函数 detach () 不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制。**

4. joinable

    > bool joinable() const noexcept;
    >
    > joinable() 函数用于**判断主线程和子线程是否处理关联（连接）状态**，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：
    >
    > true则为有连接关系
    >
    > false则为没有连接关系
    >
    > - 子线程调用了detach()函数之后，父子线程分离，同时二者的连接断开，调用joinable()返回false;
    >
    > - 在子线程调用了join()函数，子线程中的任务函数继续执行，直到任务处理完毕，这时join()会清理（回收）当前子线程的相关资源，所以这个子线程和主线程的连接也就断开了，因此，调用join()之后再调用joinable()会返回false。

5. >线程中的资源是不能被复制的，因此通过 = 操作符进行赋值操作最终并不会得到两个完全相同的对象。
    >
    >// move (1)	
    >thread& operator= (thread&& other) noexcept;
    >// copy [deleted] (2)	
    >thread& operator= (const other&) = delete;
    >
    >有此可知，如果 other 是一个右值，会进行资源所有权的转移；如果 other 不是右值，禁止拷贝，该函数被显示删除（=delete），不可用

##### 5. 线程池

>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务，节省了频繁创建和销毁线程的时间。
>
>- 空间换时间，消耗服务器硬件资源提高运行效率。
>
>- 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源。
>
>- 当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配。
>- 当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源。

1. 线程池的组成主要分为三个部分：
    1. 任务队列：**存储需要处理的任务，由工作的线程来处理这些任务**
        - 通过线程池提供的API函数，将一个待处理的任务添加到任务队列或者从任务队列中删除任务。
        - 线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程。
    2. 工作线程：**任务队列任务的消费者，N个**
        - 线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理。
        - 工作的线程相当于是任务队列的消费者角色。
        - 任务队列为空时会，工作线程会被阻塞。
    3. 管理线程：**不处理任务队列中的任务，1个**
        - 作用是周期性的对任务队列中的任务数量以及处于忙状态的工作线程的个数进行检测。
            - 当任务过多的时候，可以适当的创建一些新的工作线程。
            - 当任务过少的时候，可以适当的销毁一些工作线程。