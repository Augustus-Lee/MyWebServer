#### 1. 什么是Web Server

>web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的**程序**，一个Web Server就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机），可以**处理浏览器等Web客户端的请求并返回相应响应**。

#### 2. 用户如何与Web Server通信

>通常用户是通过Web浏览器与服务器通信的。在浏览器中键入“**域名**”或者是“**IP地址:端口号**”，浏览器则将域名解析为相应的IP地址或者直接通过IP地址向对应的Web服务器发送一个HTTP请求。
>
>

#### 3. Socket

> 传统意义上是类似于文件描述符的存在形式，是一种抽象的资源定位，即进程端口资源。socketss就是一个**资源标识**，是一个三元组（协议，端口号，IP地址）。
>
> 所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间**进行双向通信的端点的抽象**。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。

#### 4. I/O复用及相关

> 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向[内核](https://baike.baidu.com/item/内核)为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。
>
> 文件描述符：在linux系统中打开文件就会获得文件描述符，它是个很小的非负整数。每个进程在PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。

7. socket在创建的时候**默认是阻塞的**，我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。

8. I/O复用函数本身是阻塞的，它们能提高程序效率的原因是在于它们具有同时监听多个I/O事件的能力。 

9. **服务器程序通常需要处理三类事件：I/O事件，信号及定时事件**。有两种事件处理模式：

    - Reactor模式：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。**有事件发生就通知我**
    - Proactor模式：将所有的I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后`users[sockfd].read()`，选择一个工作线程来处理客户请求`pool->append(users + sockfd)`。**等事件处理完就通知我。**
    - 通常使用同步I/O模型（如`epoll_wait`）实现Reactor，使用异步I/O（如`aio_read`和`aio_write`）实现Proactor。
        1. **同步（阻塞）I/O**：在一个线程中，cpu执行速度非常快，当遇到I/O操作时，如读写操作、发送网络数据时，就需要等待I/O操作完成，才能进行下一步操作。
        2. **异步（非阻塞）I/O**：当遇到I/O操作时，先发送I/O指令，不等待返回结果，去执行其他的操作，等I/O操作已完成返回结果时，再通知cpu进行处理。

10. 三种I/O复用技术：**select、poll、epoll**（最优）

    1. 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要**将整个集合拷贝到内核态**；**epoll则将整个文件描述符集合维护在内核态**，每次添加文件描述符的时候都需要执行一个系统调用。
    2. select监听的文件描述符的有限；poll，和epoll监听的文件描述符数量可以达到系统允许的最大数目。
    3. 对于select和poll来说，只能支持相对低效的LT（电平触发）模式，而epoll则支持高效的ET（边沿触发）模式。
    4. select和poll采用的都是轮询的方式，**即每次都会扫描整个文件描述符集合，即时间复杂度为O(n)**；而epoll采用的是回调的方式，内核检测到就绪的文件描述符时，将触发回调函数，再将对应事件插入到内核就绪队列，**时间复杂度为O(1)**。
    5. epoll适用于连接数量多，但活动连接数较少的情况。连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好。

11. 两种高效**并发编程模式**：

     - 并发：让程序**“同时”执行**多个任务。实际上还是**交替执行**，由于CPU执行速度很快，会让使用者产生一种同时执行的错觉。
     - 在I/O模型中，**同步和异步**区分的是内核向应用程序中通知的是何种I/O事件（就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）；在并发模式中，**同步指的是程序完全按照代码序列的顺序执行**，异步指的是程序的执行需要由**系统事件来驱动**。常见系统事件包括中断、信号等。
     - 按照同步方式运行的线程称为**同步线程**，按照异步方式运行的线程称为**异步线程**。异步线程执行效率高，实时性强，但难以调试和扩展，不适合大量并发；同步线程效率较低，实时性低，但逻辑简单。

     1. 半同步/半异步模式：
         - 同步线程处理客户逻辑，异步线程用于处理I/O事件
         - 半同步半反应堆模式（变体）：主线程为异步线程，用于监听所有socket的事件。采用的事件处理模式是Reactor模式。
         - **缺点**：
             1. 主线程和工作线程共享请求队列，对请求队列的操作需求加锁，耗费CPU时间。
             2. 每一个工作线程在同一时间只能处理一个客户请求。客户数量多，工作线程少，请求队列任务堆积，响应满，如果添加试图通过增加线程则，由于线程切换导致的CPU时间消耗。
     2. 领导者/追随者模式：
         - 由多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任何时间点，只有一个领导者线程，它负责监听IO事件。

6. 有限状态机：**有限个状态以及在这些状态之间的转移和动作等行为的数学模型**。

     1. 可以用状态来描述事物，并且任一时刻，事物总是处于一种状态；
     2. 事物拥有的状态总数是有限的；
     3. 通过触发事物的某些行为，可以导致事物从一种状态过渡到另一种状态；
     4. 事物状态变化是有规则的，A状态可以变换到B，B可以变换到C，A却不一定能变换到C；
     5. 同一种行为，可以将事物从多种状态变成同种状态，但是不能从同种状态变成多种状态。

7. getopt函数

```cpp
 //解析命令行参数的函数
 void Config::parse_arg(int argc, char*argv[]){
     int opt;
     const char *str = "p:l:m:o:s:t:c:a:";
     while ((opt = getopt(argc, argv, str)) != -1)
     {
       switch (opt)
         {
         case 'p':
         {
             PORT = atoi(optarg);//optarg指向的是参数地址
             break;
         }
     }
       
 //---------------------
      extern char *optarg;  //选项的参数指针
      extern int optind,   //下一次调用getopt的时，从optind存储的位置处重新开始检查选项。 
      extern int opterr,  //当opterr=0时，getopt不向stderr输出错误信息。
      extern int optopt;  //当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回'？’
      int getopt(int argc, char * const argv[], const char *optstring);
 /*
 	字符串optstring是下列参数，Example："p:l:m:o:s:t:c:a:"
 	1.单个字符，表示选项
 	2.单个字符后接一个冒号表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg
 	3.单个字符后跟两个冒号，表示该选项后必须跟一个参数。参数必须紧跟在选项后 不能 以空格隔开。该参数的指针赋给optarg。
 	
 	getopt处理以'-’开头的命令行参数,如 ./server -p 9007 -l 1   -p是选项 9007是参数
 
 */
```

#### 日志系统详解

##### 1. 单例模式

>单例模式：最常用的设计模式之一，保证一个类只有一个实例，并且提供一个全局访问点，即公有的访问函数，是静态成员函数。
>
>实现思路：
>
>1. **私有化构造函数**，防止外界创建对象。
>2. 提供一个私有静态指针指向唯一实例。
>3. 提供一个公有的静态方法。
>
>**线程安全：**在拥有**共享数据的多条线程并行执行的程序中**，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。
>
>懒汉模式：顾名思义，即比较懒，当需要的时候才去初始化，避免内存浪费。（实例的初始化放在`getinstance`函数内部）
>
>>- 经典的线程安全懒汉模式，使用双检测锁模式。
>>
>>- 可以利用局部变量实现线程安全懒汉模式。（在C++11以后，要求编译器保证**静态变量初始化**的线程安全性）
>
>饿汉模式：在程序运行时就初始化，效率高，是线程安全的，但浪费内存。（实例的初始化放在`getinstance`函数外部）。

##### 2. 同步与异步

>**同步和异步通常用来形容一次方法调用。**
>
>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。
>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。
>
>它们的**区别就在于一个需要等待，一个不需要等待**，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式，比如日志记录就可以使用异步方式进行保存。

##### 3. Linux线程库及加锁

1. 线程

    >线程是轻量级进程，线程的本质是进程（Linux下）；
    >
    >线程是操作系统调度执行的最小单位，进程是资源管理和分配的最小单位；
    >
    >进程拥有自己的独立地址空间；而线程共享一块进程地址空间；
    >
    >进程上下文切换开销较大，线程相对于较小，更加节省系统资源。
    >
    >**进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。**

2. 

##### 4. C++线程库

1. 当启动了一个线程（创建了一个 thread 对象）之后，在这个线程结束的时候（std::terminate ()），我们如何去回收线程所使用的资源呢？thread 库给我们两种选择：

    - join() 加入式
    - detach()分离式

2. join

    - 在某个线程中通过子线程对象调用 join() 函数，**调用这个函数的线程被阻塞**，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后 join() 会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。
    - **函数在哪个线程中被执行，那么函数就阻塞哪个线程。**例如在主线程中调用则阻塞主线程，等待至子线程完成，才开始继续进行主线程

3. detach

    - detach() 函数的作用是进行线程分离，分离主线程和创建出的子线程。
    - 在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，**在主线程退出之前，它可以脱离主线程继续独立的运行**，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。
    - **线程分离函数 detach () 不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制。**

4. joinable

    > bool joinable() const noexcept;
    >
    > joinable() 函数用于**判断主线程和子线程是否处理关联（连接）状态**，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：
    >
    > true则为有连接关系
    >
    > false则为没有连接关系
    >
    > - 子线程调用了detach()函数之后，父子线程分离，同时二者的连接断开，调用joinable()返回false;
    >
    > - 在子线程调用了join()函数，子线程中的任务函数继续执行，直到任务处理完毕，这时join()会清理（回收）当前子线程的相关资源，所以这个子线程和主线程的连接也就断开了，因此，调用join()之后再调用joinable()会返回false。

5. >线程中的资源是不能被复制的，因此通过 = 操作符进行赋值操作最终并不会得到两个完全相同的对象。
    >
    >// move (1)	
    >thread& operator= (thread&& other) noexcept;
    >// copy [deleted] (2)	
    >thread& operator= (const other&) = delete;
    >
    >有此可知，如果 other 是一个右值，会进行资源所有权的转移；如果 other 不是右值，禁止拷贝，该函数被显示删除（=delete），不可用