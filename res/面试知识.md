## C++

### 1.const关键字

1. 修饰变量，表示改变量不可以更改
2. 修饰指针，有**指向常量的指针和指针常量**
3. 常量引用，常作为形参类型，既**避免了拷贝，又避免了值被修改**
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

常量对象成员，只能在初始化列表中赋值

### 2.static关键字

1. 修饰普通变量，修改了变量的**存储区域和生命周期**，使变量存储在静态区，在*main函数开始之前就会分配空间，*没有初始值则就会用默认值初始化
2. 修饰普通函数，**作用域隐藏**，此函数只能在定义该函数的文件内使用
3. 修饰成员变量，被整个类所拥有，不需要生成对象就可以访问
4. 修饰成员函数，也是被整个类所有拥有，不需要生成对象就可以访问该函数，但是**static函数不能访问非静态成员。**

### 3.This指针

1. this指针是一个**隐含于每一个非静态成员函数中的特殊指针**，它**指向调用该成员函数的那个对象**
2. this指针并不是一个常规变量，**而是一个右值（不能取地址）**，故不能取得this指针的地址
3. 当一个对象调用一个成员函数的时候，编译程序**先将对象的地址赋值给this指针**，每次调用成员函数存取数据成员时，都隐式使用this指针

### 4.Inline内联函数

1. 内联函数**在编译时直接将函数代码嵌入到目标代码中**，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载
2. 相当于宏，却比宏多了类型检查，宏只是简单的字符串替换；内联函数介意访问类的成员变量，而宏不可以
3. 内联函数要求是逻辑简单且重复被使用的函数，不应该包含循环，递归等操作
4. 在**类声明中定义的函数**，除了虚函数都会**隐式的被当成内联函数**。

优缺点：

1. 内联是**以代码膨胀（复制）为代价**，消除函数调用带来的开销。如果执行函数体内代码的时间比函数调用要久，那意义就不大
2. **是否内联，程序员不可控**。内来函数只是对编译器的建议，决定权在编译器

#### 虚函数可以是内联函数吗？

	>可以，内联函数可以修饰虚函数，但**当虚函数表现多态性的时候不能内联，因为内联函数是在编译期建议编译器内联，而虚函数多态是在运行期**。
	>
	>Inline virtual可以内联的时候：编译器知道所调用的对象是哪个类，**只有在编译器就具有实际对象，而不是对象的指针或者引用时**。

### 5.volatile关键字

1. volatile关键字是一种类型修饰符，volatile声明的类型变量表示可以被某些编译器的未知因素更改（如操作系统，硬件，线程等）。使用volatile会告诉编译器不应对这样的对象进行优化
2. volatile关键字修饰的变量，**每次访问时都必须从内存中取值**（普通变量可能会从CPU寄存器中取值）

#### mutable

>mutable中文意思是“易变的，可变的”，也是为了突破const的限制而设置的。被mutable修饰的变量，永远是可变的。
>
>有些时候，mutable变量在常函数中也可以修改；当需要**在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置**。

#### explicit

>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，**不能发生隐式类型转换**，只能以显式的方式发生类型转换，注意以下几点：
>
>1. **explicit只能用来于类内部的构造函数的声明上**
>2. explicit 关键字作用于**单个参数**的构造函数
>3. 不能发生相应的隐式类型转换

### 6.asset

1. 断言，是宏，而不是函数
2. 断言的作用是**其条件返回错误，则终止程序运行**
3. 可以使用NODEG关闭assert，但需要在源代码最开头，#include<assert.h>之前

### 7.extern

1. 被extern限定的函数或者变量时extern类型的
2. extern "C"修饰的变量与函数是按照C语言代码处理，可以避免 C+ 因符号修饰导致代码不能和 C 语言库中的符号进行链接的问题。

### 8.C++中struct与class区别

struct更适合当做一个数据结构的实现体，class更适合当做一个对象的实现体

1. **默认数据访问权限不同**，struct的权限是public，而class的是private
2. 默认的**继承**访问权限也不同，struct的权限是public，而class的是private

### 9.面向对象

面向对象程序设计(Object-oriented programming，OOP)是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。

面向对象三大特性：封装，继承，多态

#### 1.封装

>将客观事物封装成抽象的类，隐藏实现细节。将自己的数据和方法提供给可信的类或者对象访问，不可信的则信息隐藏。
>
>- public：可以被任意实体访问
>- protected：只允许子类及本类的成员函数、友元函数访问
>- private：只允许本类中成员函数、友元函数访问

#### 2.继承

继承：**某种类型对象获得了另一种对象类型的属性和方法**

#### 3.多态

多态，即多种形态，是同一个行为，多种实现，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为；多态是以封装和继承为基础。

>多态有静态多态和动态多态两种
>
>1. 静态多态（编译期/早绑定）
>    - 实现方法：函数重载
>    - 重载是允许有多个同名函数，但参数类型，参数个数，返回类型可能不同
>2. 动态多态（运行期/晚绑定）
>    - 实现方法：虚函数重写（覆盖）
>    - 重写：派生类重新定义基类的虚函数
>    - 多态必须是通过基本的指针或引用调用虚函数

#### 4.虚函数、纯虚函数

>虚函数：virtual int A();
>
>再基类中**冠以关键字virtual修饰的成员函数为虚函数**，它提供了一个接口界面，允许派生类对基类中的虚函数重新定义
>
>纯虚函数：virtual int A() = 0;
>
>- 是一种特殊的虚函数，**它通常作为接口存在，纯虚函数不具备函数的功能**，一般不能直接调用
>- 拥有纯虚函数的类叫做抽象类，抽象类必须用作派生其他类的基类，**不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态**。

#### 5.虚析构函数

>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生对象，防止内存泄漏。

#### 6.虚函数指针、虚函数表

>虚函数指针：
>
>1. 在含有虚函数的类的对象中，指向虚函数表
>
>

