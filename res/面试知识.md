## 1.C++

### 1.const关键字

1. 修饰变量，表示改变量不可以更改
2. 修饰指针，有**指向常量的指针和指针常量**
3. 常量引用，常作为形参类型，既**避免了拷贝，又避免了值被修改**
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

常量对象成员，只能在初始化列表中赋值

### 2.static关键字

1. 修饰普通变量，修改了变量的**存储区域和生命周期**，使变量存储在静态区，在*main函数开始之前就会分配空间，*没有初始值则就会用默认值初始化
2. 修饰普通函数，**作用域隐藏**，此函数只能在定义该函数的文件内使用
3. 修饰成员变量，被整个类所拥有，不需要生成对象就可以访问
4. 修饰成员函数，也是被整个类所有拥有，不需要生成对象就可以访问该函数，但是**static函数不能访问非静态成员。**

### 3.this指针

1. this指针是一个**隐含于每一个非静态成员函数中的特殊指针**，它**指向调用该成员函数的那个对象**
2. this指针并不是一个常规变量，**而是一个右值（不能取地址）**，故不能取得this指针的地址
3. 当一个对象调用一个成员函数的时候，编译程序**先将对象的地址赋值给this指针**，每次调用成员函数存取数据成员时，都隐式使用this指针

### 4.Inline内联函数

1. 内联函数**在编译时直接将函数代码嵌入到目标代码中**，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载
2. 相当于宏，却比宏多了类型检查，宏只是简单的字符串替换；内联函数介意访问类的成员变量，而宏不可以
3. 内联函数要求是逻辑简单且重复被使用的函数，不应该包含循环，递归等操作
4. 在**类声明中定义的函数**，除了虚函数都会**隐式的被当成内联函数**。

优缺点：

1. 内联是**以代码膨胀（复制）为代价**，消除函数调用带来的开销。如果执行函数体内代码的时间比函数调用要久，那意义就不大
2. **是否内联，程序员不可控**。内来函数只是对编译器的建议，决定权在编译器

#### 虚函数可以是内联函数吗？

1. 可以，内联函数可以修饰虚函数，但**当虚函数表现多态性的时候不能内联，因为内联函数是在编译期建议编译器内联，而虚函数多态是在运行期**。
2. Inline virtual可以内联的时候：编译器知道所调用的对象是哪个类，**只有在编译器就具有实际对象，而不是对象的指针或者引用时**。

### 5.volatile关键字

1. volatile关键字是一种类型修饰符，volatile声明的类型变量表示可以被某些编译器的未知因素更改（如操作系统，硬件，线程等）。使用volatile会告诉编译器不应对这样的对象进行优化
2. volatile关键字修饰的变量，**每次访问时都必须从内存中取值**（普通变量可能会从CPU寄存器中取值）

#### mutable

>mutable中文意思是“易变的，可变的”，也是为了突破const的限制而设置的。被mutable修饰的变量，永远是可变的。
>
>有些时候，mutable变量在常函数中也可以修改；当需要**在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置**。

#### explicit

>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，**不能发生隐式类型转换**，只能以显式的方式发生类型转换，注意以下几点：
>
>1. **explicit只能用来于类内部的构造函数的声明上**
>2. explicit 关键字作用于**单个参数**的构造函数
>3. 不能发生相应的隐式类型转换

### 6.asset

1. 断言，是宏，而不是函数
2. 断言的作用是**其条件返回错误，则终止程序运行**
3. 可以使用NODEG关闭assert，但需要在源代码最开头，#include<assert.h>之前

### 7.extern

1. 被extern限定的函数或者变量时extern类型的
2. extern "C"修饰的变量与函数是按照C语言代码处理，可以避免 C+ 因符号修饰导致代码不能和 C 语言库中的符号进行链接的问题。

### 8.C++中struct与class区别

struct更适合当做一个数据结构的实现体，class更适合当做一个对象的实现体

1. **默认数据访问权限不同**，struct的权限是public，而class的是private
2. 默认的**继承**访问权限也不同，struct的权限是public，而class的是private

### 9.面向对象

面向对象程序设计(Object-oriented programming，OOP)是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。

面向对象三大特性：封装，继承，多态

#### 1.封装

>将客观事物封装成抽象的类，隐藏实现细节。将自己的数据和方法提供给可信的类或者对象访问，不可信的则信息隐藏。
>
>- public：可以被任意实体访问
>- protected：只允许子类及本类的成员函数、友元函数访问
>- private：只允许本类中成员函数、友元函数访问

#### 2.继承

继承：**某种类型对象获得了另一种对象类型的属性和方法**

#### 3.多态

多态，即多种形态，是同一个行为，多种实现，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为；多态是以封装和继承为基础。

>多态有静态多态和动态多态两种
>
>1. 静态多态（编译期/早绑定）
>    - 实现方法：函数重载
>    - 重载是允许有多个同名函数，但参数类型，参数个数，返回类型可能不同
>2. 动态多态（运行期/晚绑定）
>    - 实现方法：虚函数重写（覆盖）
>    - 重写：派生类重新定义基类的虚函数
>    - 多态必须是通过基本的指针或引用调用虚函数

#### 4.虚函数、纯虚函数

>虚函数：virtual int A();
>
>再基类中**冠以关键字virtual修饰的成员函数为虚函数**，它提供了一个接口界面，允许派生类对基类中的虚函数重新定义
>
>纯虚函数：virtual int A() = 0;
>
>- 是一种特殊的虚函数，**它通常作为接口存在，纯虚函数不具备函数的功能**，一般不能直接调用
>- 拥有纯虚函数的类叫做抽象类，抽象类必须用作派生其他类的基类，**不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态**。

#### 5.虚析构函数

>为了防止**内存泄漏**。因为将基类的指针或引用绑定到派生类的对象，如果未将基类析构函数定义为虚函数，当我们调用析构函数时，那么**只会调用基类析构函数，释放基类的内存空间，派生类的内存空间不会释放**，则会造成内存泄漏。

#### 6.虚指针、虚函数表

>虚函数指针：在含有虚函数的类的实例化对象中，指向虚函数表
>
>虚函数表：含有虚函数的类中编译器会自动创建一个虚表，存放类中所有虚函数的地址
>
>1. 含有虚函数的每个对象都有一个指向虚函数表的指针，虚指针指向虚函数表
>2. 虚函数表是对于类，虚指针是对于对象

#### 7.虚继承

>虚继承用于解决多继承中存在的菱形继承问题（浪费资源，存在二义性）
>
>虚继承与虚函数：
>
>1. 都利用了虚指针与虚表
>2. **虚函数中的虚表存放的是虚函数的地址**
>3. **虚继承中的虚基类表中存储的是相对直接继承类的偏移**

#### 8..构造函数可以是虚函数吗

1. 不可以。构造函数是实例化对象时自动调用的，如果将构造函数定义为虚函数，而此时**对象并未创建**，则不能调用虚函数，故不能定义成虚函数。（虽然虚函数表在**编译期**就已经存在了，但是虚函数指针存在于对象实例化的内存空间中，故先有了对象才能通过虚函数指针获取虚函数表中的地址进行调用）
2. 从类型上看，构造函数实例化对象时需要明确其类型；而虚函数主要是在信息不全的情况下，能使重写的函数得到调用。
3. 从使用角度来看，构造函数是实例化对象时自动调用；虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用。

### 10.C++ 内存空间布局

1. 栈区：在执行函数时，函数内的局部变量的存储单元都可在栈上创建，**由编译器分配和释放，效率高，但内存容量有限制**
2. 堆区：动态申请的内存空间，由使用者分配和释放。如果使用者没有释放掉，则程序结束后会由操作系统释放掉。
3. 自由存储区：如果说堆是操作系统维护的一块内存，**则自由存储区是C++中通过new和delete动态分配和释放对象的一个抽象概念**。自由存储区与堆比较像，但并不等价
4. 全局/静态区：用于存储全局变量和静态变量的一块内存
5. 常量区：存放的常量，不允许被修改
6. 代码区：存放程序体的二进制代码，比如我们写的函数，都是在代码区的。

### 11.new/delete, malloc/free

相同点：都是用于内存的动态申请和释放

不同点：

1. new/delete是运算符，malloc/free是标准库函数，需要库文件支持
2. new/delete分别会调用构造函数与析构函数，malloc/free没有相关调用
3. new是类型安全的，malloc不是
4. new会自动计算分配的内存大小，而malloc需要手动计算

### 12.内存对齐

#### 1.类的对象存储空间

>1.非静态成员的数据大小之和
>
>2.编译器额外加入的成员变量（如指向虚函数表的指针）
>
>3.为了边缘对齐优化加入额外大小
>
>空类的对象大小为1

#### 2.为什么要内存对齐

1. 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同
2. 未说明原因，则按最大size的成员对齐

内存对齐的原因：内存对齐可以提高存储效率，可以提高性能

### 13.指针和引用的区别

1. 引用是一个别名，使用必须初始化；指针是一个变量，存储的是一个地址，可以为空
2. 引用一经绑定就不可更改，指针是可以改变指向对象的
3. 引用是一个别名，并不占用内存空间，指针具有内存空间
4. 指针可以是多级，引用只能是一级

#### 野指针

指向的一块**不可用内存区域的指针**，不是NULL指针，是指向“垃圾”内存的指针

1. 指针定义是未被初始化
2. 释放指针后未置空
3. **指针操作超过了变量的作用范围**

#### 空悬指针

指向最初指向的内存已经被释放了的指针，**即为指向一块未分配给用户的内存**的指针

### 14.定义一个只能在堆（栈）上生成对象的类

new一般分为三种：new operator（new表达式/new关键字）、operator new（new操作符）、placement new

new一般申请内存空间，有几个个阶段：

1. 申请内存空间，大小为指定类型对象所占用的内存大小。申请内存空间实际上是调用operator new
2. 在已经分配好的空间上，调用构造函数生成类对象。使用placement new实现
3. 返回相应指针

只在栈上：*将new重载为私有*。因为在堆上创建对象，需要使用new（new 调用operator new分配内存），禁用new则无法在堆上创建对象。

只在堆上：*将析构函数设置成私有函数*。因为编译器管理栈上对象的生命周期，**编译器在为类对象分配栈空间时，会去查看析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。**

### 15.智能指针

1. auto_ptr（在C++11中已被弃用）
    - 主要是为了解决**有异常抛出时出现的内存泄漏**
    - auto_ptr没有引用计数，故一个对象只能由一个auto_ptr拥有，在给其他auto_ptr赋值的时候，会转移所有权
    - auto_ptr赋值、拷贝之后，源对象的变得无效，故这是弃用原因
2. Shared_ptr
    - 采用引用计数器的方法，允许多个指针指向同一对象，当计数器为0的时候自动释放动态分配的资源
3. Unique_ptr
    - 独占指针采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源；故不支持赋值和拷贝操作
4. Weak_ptr
    - 引用计数窜在一个问题，就是相互引用时会造成环形引用，这样两个指针的内存都不能释放。需要weak_ptr打破环形引用
    - weak_ptr允许共享但不拥有某对象，也就是只引用，不计数。**一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空(empty)**。

### 16.类型转换运算符

1. static_cast   static_cast <typed-id> (expression)
    - 用于**转换基础类型和具有继承关系的对象指针**
    - 无运行时类型检查
2. dynamic_cast
    - 用于多态类型的转换
    - 执行运行时有类型检查
    - **只适用于指针和引用**
3. reinterpret_cast
    - 强制转换，可以将任意类型指针转换成其他任意类型指针
    - reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。
4. const_cast：**用来修改类型的const或volatile属性**

### 17.C++11特性

#### 1.nullptr

#### 2.auto/decltype

#### 3.Lambda表达式（匿名函数）

#### 4.右值引用和move语义

...

### 18.STL容器简介

#### 1.







## 2.数据结构



## 3.Linux常见命令