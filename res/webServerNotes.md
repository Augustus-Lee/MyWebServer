



### 1. 什么是Web Server

>web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的**程序**，一个Web Server就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机），可以**处理浏览器等Web客户端的请求并返回相应响应**。

### 2. 用户如何与Web Server通信

>通常用户是通过Web浏览器与服务器通信的。在浏览器中键入“**域名**”或者是“**IP地址:端口号**”，浏览器则将域名解析为相应的IP地址或者直接通过IP地址向对应的Web服务器发送一个HTTP请求。
>

### 3. Socket及TCP/IP协议

#### 1.Socket

> 传统意义上是类似于文件描述符的存在形式，是一种抽象的资源定位，即进程端口资源。socket就是一个**资源标识**，是一个三元组（协议，端口号，IP地址）。
>
> 所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间**进行双向通信的端点的抽象**。**一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。**

#### 2.TCP/IP协议

>TCP/IP四层协议丛底至上分别是是网络接口层，网际层，传输层，应用层。
>
>- 应用层常用协议：ftp、http、ssh、telnet...
>- 传输层：TCP、UDP...
>- 网络层：IP、ICMP...
>- 链路层：ARP、以太网帧协议

传输层的主要协议：

1. TCP
   - 提供面向连接的、可靠的、基于字节流的服务
   - 使用超时重传，数据确认等方式保证可靠传输
   - 支持全双工通信，每条TCP连接都是一对一的的交互通信
2. UDP
   - 提供不可靠的，无连接的、基于数据包的服务
   - 与IP协议一样，提供不可靠服务，都需要上层协议来处理数据确认和超时重传
   - 支持一对一，一对多，多对多的交互通信

##### 1.三次握手

1. 首先服务器处于listen（监听状态），等待客户端连接
2. 客户端向服务器发起请求连接报文，同步SYN=1，ACK = 0，选择一个初始序号x
3. 服务器端手到请求连接之后，确认建立连接则会发送ACK=1，SYN=1，ack = x + 1，序列号seq=y
4. 客户端瘦到服务器的连接确认报文之后，还要给服务器发送确认，则ACK = 1， ack = y + 1， seq = x+1
5. 服务器段收到确认连接之后，则连接建立

**第三次握手的原因**

为了防止失效的连接请求到达服务器，让服务器错误的打开链接。需要三次握手才能知道双方的接收和发送能力是正常的。

**如果客户端的连接请求的网络中滞留，那么会隔很久才会收到服务器发来的连接请求。**客户端经过一个超时重传时间之后，会重新发送一个连接请求给服务器，但之后滞留的连接请求也会达到服务器。如果不采用三次握手，服务器就会建立两次连接，造成资源的浪费。如果采用三次握手，客户端会对服务器对于滞留连接引起的确认报文忽略，则避免了再一次建立连接。

##### 2.四次挥手

假设为客户端主动发起连接关闭请求，因为TCP是全双工的。则步骤如下：

1. 客户端发送连接释放报文，FIN=1，初始序列号seq=u
2. 服务器收到后发送确认报文，ACK=1，seq=v，ack=u+1，此时TCP属于**半关闭状态**，服务器能向客户端发送数据额，但是，客户端不能向服务器发送数据
3. 服务器想要断开连接时，则就发送连接释放报文，FIN=1，ACK=1，seq=w，ack=u+1
4. 客户端收到连接后，发出确认连接，ACK=1，seq=u+1，ack=w+1，此时处于TIMEWAIT状态，等待2MSL（最大报文存活时间）之后进入关闭状态。
5. 服务器收到客户端的确认之后释放连接

**四次挥手的原因**  

客户端发送完FIN连接释放报文之后，服务器收到之后会进入CLOSE_WAIT状态，这**个状态是为了让服务器发送还未传送完的数据**，待服务器将数据传送完毕之后，就会发送FIN连接释放报文，故有四次挥手

**TIME_WAIT**

>**MSL**是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

客户端接收到服务器端发送的FIN报文之后进入此状态，经过时间计时器设置的2MSL时间，以后才会进入CLOSED状态。理由如下：

1. 如果客户端最后发送的确认报文丢失了，服务器并未收到，则服务器会超时重传FIN报文，故客户端可以再次发送确认报文。则等待2MSL的意义是为了确保最后一个确认报文不会丢失。
2. 等待一段时间是为了让本连接持续产生的的所有报文都从网络中消失，保证下一个新的连接不会出现旧的连接请求。

### 4. I/O复用及相关

> 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。
>
> 文件描述符：在linux系统中打开文件就会获得文件描述符，它是个很小的非负整数。每个进程在PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。

socket在创建的时候**默认是阻塞的**，我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。

I/O复用函数本身是阻塞的，它们能提高程序效率的原因是在于它们**具有同时监听多个I/O事件的能力。** 

#### 1. 事件处理模式与I/O模型

服务器程序通常需要处理三类事件：I/O事件，信号及定时事件

有两种高效的事件处理模式：

- **Reactor**模式：**要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写**），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。**有事件发生就通知我**

- **Proactor**模式：**将所有的I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑**，如主线程读完成后`users[sockfd].read()`，选择一个工作线程来处理客户请求`pool->append(users + sockfd)`。**等事件处理完就通知我。**

- 共有五种I/O模型：

    - 阻塞I/O：当执行IO操作指令时，当前执行的线程会被阻塞挂起，直至IO操作返回结果后，才能继续执行下一步的操作
    - 非阻塞I/O：当执行IO操作指令时，如果没有的正确的数据返回，则会立即返回一个错误码EWOULDBLOCK，当前线程不会被阻塞，会去执行其他操作，但会时不时的轮询IO操作结果
    - I/O复用：linux用select，poll，epoll实现IO复用模型。不同的是，这些函数可以同时阻塞多个IO操作。
    - 异步I/O：当遇到I/O操作时，先发送I/O指令，不等待返回结果，去执行其他的操作，等I/O操作已完成返回结果时，再通知当前程序继续处理。
    - 信号驱动I/O：:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。

    注意：阻塞IO，非阻塞IO，IO复用，信号驱动IO都是同步IO，

- 通常使用同步I/O模型（如`epoll_wait`）实现Reactor，使用异步I/O（如`aio_read`和`aio_write`）实现Proactor。
  
    1. **同步和异步关注的是双方的消息通信机制；阻塞和非阻塞关注的是程序在等待调用结果时的状态。**
    2. 同步阻塞I/O：在一个线程中，cpu执行速度非常快，当遇到I/O操作时，如读写操作、发送网络数据时，**就需要等待I/O操作完成，才能进行下一步操作**。
    3. 同步非阻塞I/O：此种方式下，应用发起一个I/O操作后可返回做其他事情，但需要时不时的询问I/O操作是否完成。
    4. 异步I/O：当遇到I/O操作时，先发送I/O指令，不等待返回结果，去执行其他的操作，等I/O操作已完成返回结果时，再通知cpu进行处理。

#### 2. 三种I/O复用技术：select、poll、epoll（最优）

1. 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要**将整个集合拷贝到内核态**；**epoll则将整个文件描述符集合维护在内核态**，每次添加文件描述符的时候都需要执行一个系统调用。
2. select监听的文件描述符的有限；poll，和epoll监听的文件描述符数量可以达到系统允许的最大数目。
3. 对于select和poll来说，只能支持相对低效的LT（电平触发）模式，而epoll则支持高效的ET（边沿触发）模式。
4. select和poll采用的都是轮询的方式，**即每次都会扫描整个文件描述符集合，即时间复杂度为O(n)**；而epoll采用的是回调的方式，内核检测到就绪的文件描述符时，将触发回调函数，再将对应事件插入到内核就绪队列，**时间复杂度为O(1)**。
5. epoll适用于连接数量多，但活动连接数较少的情况。连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好。

#### 3. 两种高效并发编程模式

 - 并发：让程序**“同时”执行**多个任务。实际上还是**交替执行**，由于CPU执行速度很快，会让使用者产生一种同时执行的错觉。
 - 并发模式是指I/O处理单元与多个逻辑单元之间协调完成任务的方法。
 - 在I/O模型中，**同步和异步**区分的是内核向应用程序中通知的是何种I/O事件（就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）；在并发模式中，**同步指的是程序完全按照代码序列的顺序执行**，异步指的是程序的执行需要由**系统事件来驱动**。常见系统事件包括中断、信号等。
 - 按照同步方式运行的线程称为**同步线程**，按照异步方式运行的线程称为**异步线程**。异步线程执行效率高，实时性强，但难以调试和扩展，不适合大量并发；同步线程效率较低，实时性低，但逻辑简单。

 1. 半同步/半异步模式：
     - 同步线程（相当于逻辑单元）处理客户逻辑，异步线程（I/O处理单元）用于处理I/O事件
     - 半同步半反应堆模式（变体）：主线程为异步线程，用于监听所有socket的事件，工作线程处理读读写事件。采用的事件处理模式是**Reactor模式**。
     - 半同步半反应堆模式（变体）：主线程为异步线程，有主线程来完成数据的读写，然后将应用程序数据，任务类型等信息封装为一个任务对象插入请求队列，工作线程则将之处理。这是**Proactor模式**。
     - **缺点**：
         1. 主线程和工作线程共享请求队列，对请求队列的操作需求加锁，耗费CPU时间。
         2. 每一个工作线程在同一时间只能处理一个客户请求。客户数量多，工作线程少，请求队列任务堆积，响应满，如果添加试图通过增加线程，则由于线程切换导致的CPU时间消耗。
 2. 领导者/追随者模式：
     - 由多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任何时间点，只有一个领导者线程，它负责监听IO事件。

> pthread_detach()即主线程与子线程分离，子线程结束后，**资源自动回收**。pthread_join()即是子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。

#### 4. 有限状态机

>有限状态机：**有限个状态以及在这些状态之间的转移和动作等行为的数学模型**。
>
>有限状态机是一种抽象的理论模型，逻辑单元中内部的一种高效的编程方法，在服务器编程中，服务器可以根据不同状态或者消息类型进行相应的处理逻辑，使得程序逻辑清晰易懂。
>
>被描述的事物的状态的数量是有限个。
>
>四大概念：
>
>- 状态：一个状态机至少包含两种状态。
>- 事件：执行某个动作的触发条件。
>- 动作：事件发生以后执行动作。
>- 变换：从一个状态转换成另一个状态。
>
>四个要素：
>
>- 现态：指当前所处的状态。
>- 条件：又称“事件”，当一个条件被满足，则会触发一次动作。
>- 动作：条件满足之后执行动作。动作执行完成后，可以转换成新的状态，也可以保持原状态。动作不是必须的，可以不执行动作，直接转换成新的状态。
>- 次态：条件满足之后迁移的新状态。
>
>注意：
>
>- **避免将某个程序动作当做是一种状态来处理，动作是不稳定的，即使没有条件的触发，动作一旦执行完毕就结束；而状态是稳定的，如果没有外部条件触发，状态会一直持续不变。**
>- **状态划分时漏掉一些状态，导致跳转逻辑不完整。**所以在设计状态机时，我们需要反复的查看设计的状态图或者状态表，最终达到一种牢不可破的设计方案。

本项目采用主从状态机，**从状态机读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。**

#### getopt函数

```cpp
 //解析命令行参数的函数
 void Config::parse_arg(int argc, char*argv[]){
     int opt;
     const char *str = "p:l:m:o:s:t:c:a:";
     while ((opt = getopt(argc, argv, str)) != -1)
     {
       switch (opt)
         {
         case 'p':
         {
             PORT = atoi(optarg);//optarg指向的是参数地址
             break;
         }
     }
       
 //---------------------
      extern char *optarg;  //选项的参数指针
      extern int optind,   //下一次调用getopt的时，从optind存储的位置处重新开始检查选项。 
      extern int opterr,  //当opterr=0时，getopt不向stderr输出错误信息。
      extern int optopt;  //当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回'？’
      int getopt(int argc, char * const argv[], const char *optstring);
 /*
 	字符串optstring是下列参数，Example："p:l:m:o:s:t:c:a:"
 	1.单个字符，表示选项
 	2.单个字符后接一个冒号表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg
 	3.单个字符后跟两个冒号，表示该选项后必须跟一个参数。参数必须紧跟在选项后 不能 以空格隔开。该参数的指针赋给optarg。
 	
 	getopt处理以'-’开头的命令行参数,如 ./server -p 9007 -l 1   -p是选项 9007是参数
 
 */
```

### 5. 进程

>进程是Linux环境编程的基础，它控制着系统上几乎所有的活动。
>
>进程是对**运行时程序的封装**，是**系统进行资源调度和分配的基本单位**。而线程是独立调度的基本单位（即最小的执行单位）

#### 1.进程上下文

1. **进程上下文**：就是一个进程在执行的时候，CPU中的所有寄存器中的值、进程的状态以及堆栈上的内容。当内核需要切换到另一个进程时，它需要**保存当前进程的所有状态**，即当前进程的进程上下文，当内核切换回来之后，可以继续执行。一个进程上下文可分成三个部分：**用户级上下文、寄存器上下文和系统级上下文**。
    - 用户级上下文:正文、数据、用户堆栈以及共享存储区；
    - 寄存器上下文：通用寄存器、程序寄存器、处理状态寄存器、栈指针
    - 系统级上下文：进程控制块，内存管理信息、内核栈。
2. **中断上下文**：硬件传递过来的这些参数和内核需要保存的一些其他环境。

#### 2. fork系统调用

- ```cpp
    //创建新进程的系统调用fork
    pid_t fork(void)
    /*
    1.该函数的每次调用都返回两次，父进程返回的是子进程的PID，子进程返回的是0，调用失败则返回-1
    2.fork函数复制当前进程，创建一个新的进程表项，且有许多值相同，如堆指针，栈指针，寄存器的值
    3.子进程的代码与父进程的代码完全相同，还会复制父进程的数据（堆数据，栈数据，静态数据），数据的复制采用写时复制，只有任一进程（父进程或子进程）进行写操作时，复制才会发生
    
    */
    ```

#### 3. exec系列系统调用

> 当我们需要在**子进程中**执行其他程序时，即替换当前进程镜像，则需要此系列函数。

#### 4. 处理僵尸进程

>1.父进程一般需要跟踪子进程的退出状态，因此，子进程结束运行时，内核不会立即释放该进程的进程表项。在子进程结束之后，父进程结束之前，子进程就处于僵尸态。
>
>2.父进程或者异常终止，而子进程继续运行，被称为孤儿进程。而此时由init进程接管了子进程。

1. 为了避免内核资源的浪费，从而避免僵尸进程的产生，可以使用wait/waitpid函数。

    ```cpp
    //借助于 while loop
    //以 阻塞方式 回收多个子进程
    while(wpid = waitpid(-1,NULL,0))
      
    //以 非阻塞方式 
    while(wpid = waitpid(-1,NULL,WNOHANG))
    ```

#### 5. 进程间通信

> - 进程同步：控制多个进程按一定顺序执行；
> - 进程通信：进程间传输信息。
> - **每个进程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个进程使用的共享资源）。**

1. 管道

    ```cpp
    //管道创建
    int pipe(int fd[2]);
    //参数： fd[0] -->读端   fd[1] -->写端
    //返回值  成功 --> 0  失败 --> -1   error
    ```

    >适用于有关联的进程之间的通信（父子进程）；但有一种特殊的管道，FIFO（命名管道）可以用于无关联的进程之间的通信。

    1. 双向半双工，一对这样的文件描述符只能保证一个方向之间的传输，即一个需要关闭写端，一个关闭读端
    
2. 信号量

    >信号量是一个**计数器**，可以用来**控制多个进程对共享资源的访问**。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。
3. 共享内存

    > 共享内存就是映射一段能被其他进程访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。
    >
    > 共享内存是最快的IPC方式，因为进程是直接对内存进行存取。
    >
    > 共享内存一般结合信号量一起使用，实现进程间的同步与通信。

4. 消息队列

    >消息队列是**有消息的链表**，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    >
    >- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
    >- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
    >- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。
    >

5. 套接字

    >适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。

6. 信号

    >用于通知接收进程某个事件已经发生，如ctrl+c就是信号。

### 6. 线程及加锁

#### 1. 线程

>线程是轻量级进程，线程的本质是进程（Linux下）；
>
>线程是操作系统调度执行的最小单位，进程是资源管理和分配的最小单位；
>
>进程拥有自己的独立地址空间；而线程共享一块进程地址空间；
>
>进程上下文切换开销较大，线程相对于较小，更加节省系统资源。
>
>**进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。**
>
>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

2. >每一个线程都有一个唯一的线程 ID，ID 类型为 pthread_t，这个 ID 是一个无符号长整形数
    >
    >获取线程ID的函数是：**pthread_t pthread_self()**;//返回当前线程的线程ID

#### 2. 线程同步

>当前一个线程对内存中的**共享资源**进行访问的时候，其他线程不可以对这块内存进行访问，当前线程访问完毕之后，其他线程才可以按序对其访问。**所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。**

4. 对于多个线程访问共享资源时，需要进行线程同步。常用的线程同步方式：**互斥锁，读写锁，条件变量，信号量四种。**

    - 互斥锁：pthread_mutex_t  mutex

        - 一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。**一般情况下，每一个共享资源对应一个把互斥锁，锁的个数和线程的个数无关。**
        - 死锁：如果锁使用不当，就会造成**死锁**这种现象。如果线程死锁造成的后果是：**所有的线程都被阻塞，并且线程的阻塞是无法解开的**。导致死锁有以下场景：
            - 加锁之后忘记解锁
            - 重复加锁
            - 有多个共享资源，故有很多锁，若随意加锁，会导致阻塞

    - 读写锁

        >pthread_rwlock_t  rwlock;
        >
        >读写锁是互斥锁的升级版，读操作的时候可以提高程序执行效率，**如果线程的操作都是读操作，那么是并行的，但使用互斥锁则是串行的。**

        - 读锁是共享的，写锁是独占的，写锁优先级比读锁高。

    - 条件变量

        - 如果说互斥锁是用于同步线程**对共享数据的访问**，那么条件变量则是用于在线程之间同步**共享数据的值。**

        - 条件变量的主要作用**不是实现线程同步，而是线程阻塞。**

        - 一般情况下，条件变量用于处理生产者和消费者模型，并且配合互斥锁使用。
    
            >pthread_cond_t cond;  创建一个条件变量类型的变量
            >
            >pthread_cond_signa;l 唤醒至少一个被阻塞的线程
        >
            >pthread_cond_broadcast; 唤醒所有被阻塞的线程

        - 生产者和消费者模型，有三种工作角色
    
            - 生产者线程：若干个，缓冲区满时则，则阻塞
        - 消费者线程：若干个，缓冲区为空时，则阻塞
            - 缓冲区：**为了读写访问可以通过一个数据结构维护这块内存**，可以是队列，链表，数组等等

    - 信号量

        - 信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。

        - 控制一个具有有限数量的用户资源数
    
        - 信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为 sem_t 对应的头文件为 <semaphore.h>
        
            >#include <semaphore.h>
            >sem_t sem;
            >
            >//sem:信号量变量
            >
            >//pshared: 0->表示线程同步  非0表示进程同步
            >
            >//value: 初始化当前信号量拥有的资源数（>0），等于0表示线程会被阻塞
    >
            >int sem_init(sem_t *sem, int pshared, unsigned int value);
    
        - >//在总资源数大于1的多线程多任务中  这两行代码顺序不能改变  否则会造成死锁
            >
            >sem_wait(&sem)
            >
            >Pthread_mutex_lock(&mutex)

#### 3. C++线程库

1. 当启动了一个线程（创建了一个 thread 对象）之后，在这个线程结束的时候（std::terminate ()），我们如何去回收线程所使用的资源呢？thread 库给我们两种选择：

    - join() 加入式
    - detach()分离式

2. join

    - 在某个线程中通过子线程对象调用 join() 函数，**调用这个函数的线程被阻塞**，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后 join() 会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。
    - **函数在哪个线程中被执行，那么函数就阻塞哪个线程。**例如在主线程中调用则阻塞主线程，等待至子线程完成，才开始继续进行主线程

3. detach

    - detach() 函数的作用是进行线程分离，分离主线程和创建出的子线程。
    - 在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，**在主线程退出之前，它可以脱离主线程继续独立的运行**，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。
    - **线程分离函数 detach () 不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制。**

4. joinable

    > bool joinable() const noexcept;
    >
    > joinable() 函数用于**判断主线程和子线程是否处理关联（连接）状态**，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：
    >
    > true则为有连接关系
    >
    > false则为没有连接关系
    >
    > - 子线程调用了detach()函数之后，父子线程分离，同时二者的连接断开，调用joinable()返回false;
    >
    > - 在子线程调用了join()函数，子线程中的任务函数继续执行，直到任务处理完毕，这时join()会清理（回收）当前子线程的相关资源，所以这个子线程和主线程的连接也就断开了，因此，调用join()之后再调用joinable()会返回false。

5. >线程中的资源是不能被复制的，因此通过 = 操作符进行赋值操作最终并不会得到两个完全相同的对象。
    >
    >// move (1)	
    >thread& operator= (thread&& other) noexcept;
    >// copy [deleted] (2)	
    >thread& operator= (const other&) = delete;
    >
    >有此可知，如果 other 是一个右值，会进行资源所有权的转移；如果 other 不是右值，禁止拷贝，该函数被显示删除（=delete），不可用

#### 4. 线程池

>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务，节省了频繁创建和销毁线程的时间。
>
>- 空间换时间，消耗服务器硬件资源提高运行效率。
>
>- 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源。
>
>- 当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配。
>- 当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源。

1. 线程池的组成主要分为三个部分：
    1. 任务队列：**存储需要处理的任务，由工作的线程来处理这些任务**
        - 通过线程池提供的API函数，将一个待处理的任务添加到任务队列或者从任务队列中删除任务。
        - 线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程。
    2. 工作线程：**任务队列任务的消费者，N个**
        - 线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理。
        - 工作的线程相当于是任务队列的消费者角色。
        - 任务队列为空时会，工作线程会被阻塞。
    3. 管理线程：**不处理任务队列中的任务，1个**
        - 作用是周期性的对任务队列中的任务数量以及处于忙状态的工作线程的个数进行检测。
            - 当任务过多的时候，可以适当的创建一些新的工作线程。
            - 当任务过少的时候，可以适当的销毁一些工作线程。

### 7.日志系统

#### 1. 单例模式

>单例模式：最常用的设计模式之一，保证一个类只有一个实例，并且提供一个全局访问点，即公有的访问函数，是静态成员函数。
>
>实现思路：
>
>1. **私有化构造函数**，防止外界创建对象。
>2. 提供一个私有静态指针指向唯一实例。
>3. 提供一个公有的静态方法。
>
>**线程安全：**在拥有**共享数据的多条线程并行执行的程序中**，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。
>
>懒汉模式：顾名思义，即比较懒，当需要的时候才去初始化，避免内存浪费。（实例的初始化放在`getinstance`函数内部）
>
>>- 经典的线程安全懒汉模式，使用双检测锁模式。
>>
>>- 可以利用局部变量实现线程安全懒汉模式。（在C++11以后，要求编译器保证**静态变量初始化**的线程安全性）
>
>饿汉模式：在程序运行时就初始化，效率高，是线程安全的，但浪费内存。（实例的初始化放在`getinstance`函数外部）。

#### 2. 同步与异步

>**同步和异步通常用来形容一次方法调用。**
>
>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。
>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。
>
>它们的**区别就在于一个需要等待，一个不需要等待**，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式，比如日志记录就可以使用异步方式进行保存。

#### 3.日志系统实现机制详解

日志：由服务器自动创建，并记录运行状态，错误信息，访问数据的文件

- 同步日志：日志写入函数与工作线程串行执行，由于涉及I/O操作，当日志过大时，同步日志会阻塞整个处理流程，服务器所能处理的并发能力就会下降。
- 异步日志：将所写的日志先存入阻塞队列，然后写线程从阻塞队列中获取日志信息，再写入日志

阻塞队列：将生产者，消费者模型封装，使用循环数组实现队列，作为两者之间的缓冲区

单例模式：保证一个类值创建一个实例，并提供一个全局访问点

>**流程：**
>
>- 日志文件
>    - 局部变量的懒汉模式获取唯一实例
>    - 生成日志文件，判定是同步还是异步（根据阻塞队列大小，若设置了阻塞队列大小则为异步，否则同步）
>- 同步
>    - 判断是否份文件（按天或者超行都要分文件）
>    - 直接格式化输出内容，将信息写入日志文件
>- 异步
>    - 判断是否份文件
>    - 格式化输出内容至阻塞队列，然后创建一个写线程，再将信息从阻塞队列取出写入至日志文件



### 8. HTTP连接

#### 1. I/O复用及其相关详解

##### Fd详解

>Fd:是一个正整型数，**实际是为文件描述符表（数组）的索引，文件描述符表中保存着已打开的文件的指针。**
>
>每一个进程在PCB（Process Control Block）即进程控制块中都保存着一分文件描述符表，文件描述符就是这个表的索引，文件描述符表中每个表项都有一个指向已打开文件的指针。现在我们明确一下：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。
>
>file结构体才是内核中用来描述文件属性的结构体。

##### 系统调用详解

>系统调用的基本概念：通常，在操作系统中都设置了**一组用于实现各种系统功能的子程序**，并将它们提供给应用程序调用。
>
>程序接口是 OS 专门为用户程序设置的，也是用户程序取得 OS 服务的唯一途径。程序接口通常是由各种类型的系统调用所组成的，因而，也可以说，**系统调用提供了用户程序和操作系统之间的接口，应用程序通过系统调用实现其与 OS 的通信，并可取得它的服务**。
>
>操作系统中提供了系统调用，使应用程序可以**通过系统调用的方法，间接调用操作系统的相关过程，取得相应的服务**。
>
>**软件中断实现系统调用：**
>
>- 软件中断：它是通过软件指令触发的中断。Linux系统内核响应软件中断，从用户态切换到内核态，执行相应的系统调用。

##### 1.Select

```cpp
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

select允许应用程序监视一组文件描述符，等待一个或者多个文件描述符成为就绪状态，从而完成I/O操作。

- fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，**所以只能监听少于 FD_SETSIZE 数量的描述符**。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。
- timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。

- 成功调用返回结果大于 0，**出错返回结果为 -1，超时返回结果为 0。**

##### 2.Poll

```cpp
int poll(struct pollfd *fds, unsigned int nfds, int timeout);
//当timeout为-1时，poll调用将会永远阻塞，直到某个事件发生；timeout为0时，则立即返回
```

poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。

Select与Poll比较：

1. select默认监听的文件描述符最大是1024，但可以修改，poll则没有文件描述符的限制。
2. poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。

##### 3.Epoll

```cpp
/*
1.epoll采用一组函数来完成任务，而不是一个函数
2.epoll把用户关心的文件描述符上的事件放在内核里的事件表中，从而无须像select和poll每次调用都要重复传入文件描述符集或事件集
*/

//创建一个指示epoll内核事件表的文件描述符，该描述符将用作其他epoll系统调用的第一个参数，size不起作用。
int epoll_create(int size);

//该函数用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
  
//在一段超时时间内等待一组文件描述符上的事件，成功则返回就绪文件描述的个数
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

- epoll_ctl()用于向内核注册新的描述符或者改变某个文件描述符的状态。已注册的文件描述符在内核中会被维护在一棵红黑树上。

- epoll比select和poll更灵活，没有文件描述符数量的限制。

- 工作模式：

    epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。

    1. LT模式

        >当epoll_wait()检测fd上有事件发生并将此事件通知应用程序后，将此事会通知给进程，**进程可以不立即处理该事件**，当应用程序下一次调用epoll_wait()时，epoll_wait还会再次向应用程序通知此事件，直到此事件被处理。同时支持 Blocking 和 No-Blocking。

    2. ET模式

        >当epoll_wait()检测fd上有事件发生并将此事件通知应用程序后，**应用程序必须立即处理该事件**，因为后续epoll_wait()将不会再向应用程序通知该事件。
        >
        >只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

    **ET模式在很大程度上降低了epoll事件被重复触发的次数，因此ET模式效率比LT模式高。**
    
    3. EPOLLONESHOT
    
       >为了避免多个多个线程同时操作一个Socket，可以注册EPOLLONESHOT事件。
       >
       >我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，**当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件**

##### 同于异

>1. select和poll的文件描述符是在**用户态**加入文件描述符集合的，每次调用都需要将整个集合拷贝至内核态；而epoll的文件描述符维护在**内核态**，每次添加文件描述符的时候都需要执行一次系统调用。
>2. select使用线性表描述文件描述符集合，文件描述符有上限；poll用链表描述，无上限；epoll则用红黑树描述文件描述符集合，且也没有上限。
>3. select和poll需要通过遍历整个文件描述符集合，判断哪个文件描述符上有事件发生；而epoll会维护一个ready list，会将就绪事件添加至list，每次调用epol_wait的时候，仅观察list是否有数据即可。

##### 应用场景

1. select应用场景

    >elect 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。
    >
    >select 可移植性更好，几乎被所有主流平台所支持。

2. poll应用场景

    >poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。

3. epoll应用场景

    >只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接，因为Epoll的文件的描述符都存在内核中，需要通过系统调用epoll_ctr来改变文件描述符状态，频繁操作会降低效率。
    >
    >需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。

#### 2. HTTP报文格式

> HTTP报文分为请求报文和响应报文两种，每种报文必须按照特有格式生成，才能被浏览器识别。
>
> 浏览器（客户端）向服务器发送的为请求报文，服务器向浏览器发送的是响应报文。

##### 1.请求报文

> HTTP请求报文由请求行(request line)，请求头部(header)，空行与请求数据组成。介绍其中两种：

- GET

    > 1  GET /562f25980001b1b106000338.jpg HTTP/1.1
    > 2  Host:img.mukewang.com
    > 3  User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64)
    > 4  AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
    > 5  Accept:image/webp,image/*,*/*;q=0.8
    > 6  Referer:http://www.imooc.com/
    > 7  Accept-Encoding:gzip, deflate, sdch
    > 8  Accept-Language:zh-CN,zh;q=0.8
    > 9  空行
    >10  请求数据为空

- POST

    >1  POST / HTTP1.1
    >2  Host:www.wrox.com
    >3  User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
    >4  Content-Type:application/x-www-form-urlencoded
    >5  Content-Length:40
    >6  Connection: Keep-Alive
    >7  空行
    >8  name=Professional%20Ajax&publisher=Wiley

    **GET与POST的区别**：

    1. GET 用于获取资源，而 POST 用于传输实体主体。
    2. 是否有请求数据，GET是只读，故没有请求数据，POST可能会影响服务器资源的更新，有请求数据。
    3. 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是安全的，而 POST 却不是。

##### 2.响应报文

> HTTP响应也是由四部分组成，分别是：状态行，消息报头，空行，响应正文。

>1HTTP/1.1 200 OK
> 2Date: Fri, 22 May 2009 06:07:21 GMT
> 3Content-Type: text/html; charset=UTF-8
> 4空行
> 5<html>
> 6   <head></head>
> 7   <body>
> 8      <!--body goes here-->
> 9   </body>
>10</html>
>
>- 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
>    第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。
>- 消息报头，用来说明客户端要使用的一些附加信息。
>    第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8。
>- 空行，消息报头后面的空行是必须的。
>- 响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。

##### 3.HTTP状态码和状态消息

>一般分为五大类，分别用1XX - 5XX开头
>
>- 1xx：**指示信息 ** --> 表示请求已接收，继续处理。
>
>- 2xx：**成功 ** --> 表示请求正常处理完毕。
>
>- - 200 OK：客户端请求被正常处理。
>    - 206 Partial content：客户端进行了范围请求。
>
>- 3xx：**重定向 ** --> 要完成请求必须进行更进一步的操作。
>
>- - 301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。
>    - 302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。
>
>- 4xx：**客户端错误 ** -->  请求有语法错误，服务器无法处理请求。
>
>- - 400 Bad Request：请求报文存在语法错误。
>    - 403 Forbidden：请求被服务器拒绝。
>    - 404 Not Found：请求不存在，服务器上找不到请求的资源。
>
>- 5xx：**服务器端错误 ** -->  服务器处理请求出错。
>
>- - 500 Internal Server Error：服务器在执行请求时出现错误。

### 9.定时器

#### 1. 基础知识

>`非活跃`，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。
>
>`定时事件`，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。
>
>`定时器`，是容器内容纳的一个个对象，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。
>
>`定时器容器`，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。

#### 2. SIGALRM信号

>Linux下有三种定时方法：
>
>1.socket选项SO_RECVTIMEO和SO_SNDTIMEO 
>
>2.SIGALRM信号
>
>3.I/O复用系统调用的超时参数
>
>SIGALRM信号：利用`alarm`函数周期性地触发`SIGALRM`信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。
>
>定时器通常至少包含两个成员：一个超时时间，和一个任务回调函数。

1. 基础API

    >```cpp
    >// sigaction结构体
    >struct sigaction {
    >    void (*sa_handler)(int);
    >    void (*sa_sigaction)(int, siginfo_t *, void *);
    >    sigset_t sa_mask;
    >    int sa_flags;
    >    void (*sa_restorer)(void);
    >	}
    >/*
    >sa_handler是一个函数指针，指向信号处理函数
    >
    >sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息
    >
    >sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号
    >
    >sa_flags用于指定信号处理的行为
    >
    >	- SA_RESTART，使被信号打断的系统调用自动重新发起
    >
    >	- SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号
    >
    >	- SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程
    >
    >	- SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号
    >
    >	- SA_RESETHAND，信号处理之后重新设置为默认的处理方式
    >
    >	- SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数
    >
    >sa_restorer一般不使用
    >*/
    >
    >// sigaction函数
    >int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
    >/*
    >signum表示操作的信号。
    >
    >act表示对信号设置新的处理方式。
    >
    >oldact表示信号原来的处理方式。
    >
    >返回值，0 表示成功，-1 表示有错误发生。
    >*/
    >
    >int sigfillset(sigset_t *set);
    >/*
    >用来将参数set信号集初始化，然后把所有的信号加入到此信号集里。
    >*/
    >
    >unsigned int alarm(unsigned int seconds);
    >/*
    >设置信号传送闹钟，即用来设置信号SIGALRM在经过参数seconds秒数后发送给目前的进程。如果未设置信号SIGALRM的处理函数，那么alarm()默认处理终止进程.
    >*/
    >
    >int socketpair(int domain, int type, int protocol, int sv[2]);
    >/*
    >在linux下，使用socketpair函数能够创建一对套接字进行通信，项目中使用管道通信。
    >domain表示协议族，PF_UNIX或者AF_UNIX
    >
    >type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP
    >
    >protocol表示类型，只能为0
    >
    >sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作
    >
    >返回结果， 0为创建成功，-1为创建失败
    >*/
    >
    >ssize_t send(int sockfd, const void *buf, size_t len, int flags);
    >/*
    >当套接字发送缓冲区变满时，send通常会阻塞，除非套接字设置为非阻塞模式，当缓冲区变满时，返回EAGAIN或者EWOULDBLOCK错误，此时可以调用select函数来监视何时可以发送数据。
    >*/
    >```

#### 3. 信号通知流程

Linux下的信号采用异步处理机制，信号处理函数与当前进程是两条不同的执行线。为避免信号处理函数执行时间过长，导致信号屏蔽太久，**故信号处理函数仅发送信号通知程序主循环**，将信号对应的处理逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。

- 统一事件源：是指将信号事件与其他事件一样被处理。

    - 具体的，信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值，使用I/O复用系统调用来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过epoll来监测，从而实现统一处理。

- 信号处理机制

    每个进程之中，都有存着一个表，里面存着每种信号所代表的含义，内核通过设置表项中每一个位来标识对应的信号类型。

    1. 信号的接收
    2. 信号的检测
    3. 信号的处理

- 信号通知逻辑

    1. 创建管道，其中管道写端写端写入信号，管道读端使用I/O复用系统监测读事件
    2. 设置信号处理函数
    3. 利用I/O复用技术监听读端文件描述符的可读事件
    4. 信息传递给主循环，主循环再根据接收的信号值执行目标信号值对应的逻辑代码。

#### 4. 定时器设计

​	将连接资源、定时事件和超时时间封装为定时器类

- 连接资源包括客户端套接字地址，文件描述符和定时器
- 定时事件为回调函数，将其封装起来由用户自定义，
- 定时器超时时间 = 浏览器与服务器连接时间 + 固定时间（TIMESLOT），定时器使用绝对时间作为超时值

#### 5. 定时器容器设计

​	定时器容器为**带头尾节点的升序双链表**，具体的为每一个连接创建一个定时器，将其添加到链表中，并按照超时时间升序排序。执行定时任务时，将到期的定时器从链表中删除。

- 从实现上看，主要涉及双向链表的插入，删除操作，添加定时器的时间复杂度为O(n)，删除的是O(1)。
- 升序双向链表主要逻辑如下：
    - 创建头尾节点，并无实际含义，仅为方便操作
    - add_timer函数，将目标定时器按升序添加至链表中
    - adjust_timer函数，当定时任务发生变化，动态调整定时器在链表中的位置
    - del_timer函数，将超时的定时器从链表中删除。

#### 6.定时任务处理函数

​	使用同一事件源，**SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数**，处理链表容器中到期的定时器。

​	服务器首先创建定时器容器链表，然后统一事件源将异常事件，读写事件，信号事件统一处理，根据不同事件的逻辑使用定时器。

### 10. 数据库连接池

>数据库连接池：
>
>- 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化。本质是对资源的复用。
>- 连接池中的资源为一组数据库连接池，由程序动态的对池中的连接进行使用，释放。
>- 当系统开始处理客户请求的时候，需要什么资源可以去连接池中获取，不用动态分配创建；当服务器处理完一个客户连接的时候，可以将相关资源放进池中，无需执行系统调用释放资源。
>
>一般的数据库流程：先系统创建数据库连接，再进行数据库访问，在释放数据库连接。
>
>数据库连接池优点：
>
>- 频繁的创建和释放数据库连接非常浪费资源，故数据库连接池资源得到了复用，性能得到提升。
>- 更快的响应速度，也更加安全可靠。
>
>**连接池的功能主要有：初始化，获取连接，释放连接，销毁连接池。**

#### 1.RAII机制

> RAII(Resource Acquisition Is Initialization)：**资源获取就是初始化，是用来管理资源、避免资源泄漏的方法，即对象在构造时获取资源**，且在对象的声明周期内资源始终有效，**最后在对象析构的时候释放资源**。即**将一份资源管理的责任交给了一个对象**。
>
> **RAII的做法就是使用一个对象，在其构造的时候获取对应的资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，在析构的时候的释放资源。**

### 11.基础命令

#### 1.tcpdump

- 经典的网络抓包工具

#### 2.lsof(list open file)

- 列出当前系统打开的文件描述符的工具
- -i，显示socket文件描述符，lsof -i [46] [protocol] [@hostname] [ipaddress] [:service|port]
    - 4,6表示IPV4或者IPV6
    - protocol指定传输层协议，可以是TCP，UDP
    - hostname指定主机名
    - ipaddress指定主机IP地址
    - service|port指定服务名，port指定端口号
- -c，显示指定的命令打开的所有文件描述符
- -p，**显示指定进程打开的所有文件描述符**

#### 3.nc(netcat)

- 主要被用来快速构建网络连接。可以让它以服务器方式运行，监听某个端口并与接收客户端连接，可以用来调试客户端连接
- -i，设置数据包传送的时间间隔
- -l，以服务器方式运行，监听指定的端口。nc命令默认以客户端方式运行
- -k，重复接受并处理某个端口上的所有连接，必须与-l选项一起使用

#### 4.strace

1. 测试服务器性能的重要工具。它跟踪程序运行过程中执行的系统调用和接收到的信号
2. 参数：
    - -c，统计每个系统调用执行时间，执行次数和出错次数
    - -f，跟踪由fork调用生成的子进程
    - -d，输出strace关于标准错误的调试信息

#### 5.netstat

1. 功能强大的网络信息统计工具。可以打印本地网卡接口上的全部连接、路由表信息、网卡接口信息等。
2. 参数：
    - -n，使用IP地址表示主机，而不是主机名；使用数字表示端口，而不是服务名
    - -a，显示结果中也包含监听Socket
    - -t，仅显示tcp连接
    - -r，显示路由信息

#### 6.PS(process status)

1. 最基本的进程查看命令，使用该命令可以看到哪些进程正在运行以及运行状态等
2. **ps命令是显示瞬间进程的状态，并不是动态连续的，如果想对进程进行实时监控应使用top命令**
3. 参数：
    - -A，所有进程均显示出来，与e有同样效果
    - -a，显示现行终端机下所有进程，包括其他用户的进程
    - -u，以用户为主的进程状态
    - x，通常与a一起使用，可列出较完整信息
    - ps aux | grep  相应进程号  或者 ps ef | grep 相应进程号

#### 7.grep

1. 文本处理工具之一，搜索文本内容，常用格式：grep [选项] "模式" 文件 ，grep -c "test" test.cpp（统计当前目录下的test.cpp中匹配到test有多少行）
2. 参数：
    - -E，开启扩展的正则表达式
    - -v，反过来，**只打印没有匹配的**
    - -i，忽略大小写
    - -n，显示行号
    - --color，将匹配到的颜色高亮
    - -c，显示多少行被匹配到了
    - -w，精确匹配
    - -A n，显示匹配到的字符串所在的行及其后n行（After），同理可得前n行 -B n（Before）

#### 8.awk

#### 9.sed

1. 一个很好的文件处理工具，本身是一个管道命令，**主要是以行为单位进行处理**，可以将数据进行替换，删除，新增等操作。命令行格式： sed [常用选项] [命令选项] 文本
2. 常用选项
    - -n，使用slient（安静）模式，一般所有来自 STDIN的资料一般都会被列出到屏幕上。此选项只显示处理过的行
    - -i，直接修改读取的文本内容
3. 常用命令
    - a，新增，在指定行后面追加内容（以行为处理单位），使用\n追加多行
    - c，取代
    - d，删除，‘2,nd’删除2至n行
    - i，插入，在行前面插入文本
    - p，列印，通常与-p一起使用
    - s，可以直接进行取代





### 12. 问题相关

#### 1.项目介绍

- 为什么要做这样一个项目？

    - 想要从事C++后端方面的工作，故可以做一个小的项目将所学的知识，如C++语法，TCP/IP协议，网络编程，进程通信/线程同步，Linux下环境编程，融会贯通起来使用。

- 介绍下你的项目

    >这个项目主要的目的是对**浏览器的链接请求进行解析处理，处理完之后给浏览器客户端返回一个响应，如文字图片视频等**。服务器后端的处理方式**使用socket通信，利用多路IO复用**，可以同时处理多个请求，请求的解析使**用预先准备好的线程池**，使用模拟proactor模式，**主线程负责监听**，监听到有事件之后，从socket中循环读取数据，然后将读取到的数据封装成一个请求对象插入请求队列。睡眠在请求队列上的**工作线程被唤醒进行处理**。处理的方式用**状态机**。
    >
    >对请求文件的处理：客户端发出链接，到达服务器，服务器这端先用read_once（）函数一次性把所有请求读到缓冲区。然后process_read函数分别调用用三个函数对缓冲区的内容进行解析。主状态机主要用于解析客户端请求，从状态机用于解析一行内容并把每一行加\0\0格式化，方便主状态机解析，主状态机调用解析请求行，请求头，请求内容三部分函数进行解析。解析结束后利用do_request（）函数生成响应报文，该函数会根据不同的网址url产生不同响应体。最后通过write函数里套接字的传输方式把响应体传给客户端。
    >
    >日志分为**同步日志和异步日志**，异步日志利用阻塞队列，先将日志放入阻塞队列中，然后利用条件变量将日志添加到对应文件中。采用**单例模式**。
    >
    >日志系统初始化函数中主要要做的事：如果文件名没带路径，直接放到log_full_name。如果带路径，把文件名取出来放到log_name，把路径取出来放到dir_name，然后把时间+log_name放到log_full_name。
    >
    >在write_log（）函数中，这里面有两部分，一部分是对新的文件名，时间，日志名进行再次处理，一部分是时间+新加入的日志参数放入缓冲区。异步加入阻塞队列，同步直接写入日志文件。阻塞队列是用数组模拟的生产者消费者模式。根据初始化函数传入的最后一个参数阻塞队列最大容纳值判断是同步还是异步，异步则其大于等于1。
    >
    >用**单例模式创建了数据库连接池**。数据库链接池中，提前创建一定量的数据链接，并把他们保存在双向链表中。
    >
    >**用定时器处理非活动链接，定时器容器利用升序链表进行设计**。
    
- 项目的一个解决的难点

    >**关于大文件传输**
    >
    >1. 高级I/O函数writev和readv
    >
    >    write，read一次只能传输连续的内存数据，而writev，readv一次是可以传输不连续的内存数据
    >
    >    readv函数将数据从文件描述符读到分散的内存块中，即分散读；
    >
    >    writev函数将多块分散的内存数据写入文件描述符中，即集中写；
    >
    >2. 问题
    >
    >    - 当请求为小文件的时候的，调用一次writev函数就可将数据全部发送出去，不会报错；但如果请求服务器较大文件的时候，需要多次调用writev函数，便会出现问题，要么文件显示不全，要么就无法显示
    >
    >3. 解决方法
    >
    >    1. 经过分析是writev函数的iov结构体成员有问题，每次传输后不会自动偏移文件指针和传输长度，还会按照原有指针和原有传输长度发送数据
    >    2. writev以顺序iov[0], iov[1]至iov[iovcnt - 1]从缓冲区将数据聚集输出数据
    >    3. 申请了两个iov，其中iov[0]为存储报文状态行的缓冲区，iov[1]指向资源文件指针
    >    4. 由于报文消息报头较小，第一次传输后，需要更新m_iv[1].iov_base和iov_len，m_iv[0].iov_len置成0
    >    5. 每次传输后，都要更新文件起始位置和长度

    ```cpp
    ssize_t readv(int fd, const struct iovec* vector, int count)
    
    ssize_t writev((int fd, const struct iovec* vector, int count)
    /*
    fd是被操作的文件描述符，vector是一个iovec结构数组，该结构体描述一块内存区
    count是vector数组的长度，即有多少块内存数据需要从fd读出或写到fd
    */
    struct iovec {
    2    void      *iov_base;      /* starting address of buffer */
    3    size_t    iov_len;        /* size of buffer */
    4};
    /*
    定义了一个向量元素，通常，这个结构用作一个多元素的数组。
    iov_base指向数据的地址
    iov_len表示数据的长度
    */
    ```

    

#### 2.线程池相关

- 手写线程池

- 线程的同步机制有哪些？

    1. 互斥锁：一个互斥锁只能被一个线程锁定
    2. 条件变量：如果说互斥锁是**用于同步线程共享数据的访问**，则条件变量就是同步线程间**共享数据的值**，主要作用是线程阻塞
    3. 信号量：主要用于阻塞线程，也可用于进程间同步，可以指定资源数

- 线程池中的工作线程是一直等待吗？

    >线程池的工作线程是处于一直阻塞等待的模式下的。在创建线程池的时候，默认创建了8个工作线程，当请求队列不为空的时候，会一直处于阻塞等待模式下。
    >
    >

- 你的线程池工作线程处理完一个任务后的状态是什么？

    >1. 当请求队列为空的时候，则这个线程重新回到阻塞等待的状态
    >2. 请求队列不为空的时候，那这个线程就处于与其他线程竞争资源的状态
    >
    >

- 如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？

    >- 创建线程的时候就调用pthread_deatch将线程进行分离了，就不用单独对工作线程进行回收
    >- 且当请求队列不为空的时候，工作线程不会终止，没有任务会永远阻塞等待，本项目则有8个工作线程同时处理任务，处理完之后循环继续处理，直至请求队列为空或者任务全部处理完成
    >
    >

- 如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?

    >会影响，因为线程池中工作线程数量有限，占用事件过长会影响到处理请求效率。可以为线程处理请求对象设置超时时间，超过时间先发送信号告知线程处理超时，然后设定一个时间间隔再次检测，若此时这个请求还占用线程则直接将其断开连接
    >
    >

#### 3.并发模型相关

- 简单说一下服务器使用的并发模型？

- reactor、proactor、主从reactor模型的区别？

    >Reactor是：
    >
    >主线程往epoll内核上注册socket读事件，主线程调用epoll_wait等待socket上有数据可读，当socket上有数据可读的时候，主线程把socket可读事件放入请求队列。睡眠在请求队列上的某个工作线程被唤醒，处理客户请求，然后往epoll内核上注册socket写请求事件。主线程调用epoll_wait等待写请求事件，当有事件可写的时候，主线程把socket可写事件放入请求队列。睡眠在请求队列上的工作线程被唤醒，处理客户请求。

    	Proactor:
    	主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读完成后如何通知应用程序，主线程继续处理其他逻辑，当socket上的数据被读入用户缓冲区后，通过信号告知应用程序数据已经可以使用。应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后调用aio_write函数向内核注册socket写完成事件，并告诉内核写缓冲区的位置，以及写完成时如何通知应用程序。主线程处理其他逻辑。当用户缓存区的数据被写入socket之后内核向应用程序发送一个信号，以通知应用程序数据已经发送完毕。应用程序预先定义的数据处理函数就会完成工作。
    
Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，Proactor模式中，应用程序不需要进行实际读写过程。
    
- 你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？

  epoll的效率更高，故使用Epoll

  1. select：文件描述符数量受限，默认最多为1024；采用线性表描述文件描述符集合，需要以轮询的方式去访问文件描述符，判断哪个文件描述符上有事件发生；工作在效率较低的LT模式下
  2. poll：突破了文件描述符数量的限制；采用链表描述文件描述符集合，也是轮询的方式访问文件描述符表；工作在效率较低的LT模式下
  3. epoll：无描述符数量限制；使用ET和LT模式；采用红黑树描述文件描述符集合，会维护一个就绪链表，会将就绪事件添加至list，则调用epoll_wait时仅需判断list是否有数据，极大的提高了应用程序索引就绪文件描述符的效率

#### 4.HTTP报文解析相关

- 用了状态机啊，为什么要用状态机？

    >因为传统应用程序的控制流程基本是按顺序执行：按照事先设定的逻辑，从头到尾的执行。
    >
    >状态机则能处理任何顺序的事件，并能提供有意义的相应，即使这些事件发生的数据不同

- 状态机的转移图画一下

- https协议为什么安全？

    >HTTPS = http + SSL/TLS，会对传输的数据进行加密，HTTPS采用对称加密和非对称加密混合的加密方式
    >
    >使用**非对称密钥加密用于传输对称密钥来保证传输过程的安全性**，之后使用**对称密钥加密进行通信来保证通信过程的效率**。
    >
    >数据隐私性：数据内容经过对称加密
    >
    >数据据完整性：内容传输经过完整性校验
    >
    >身份认证：通过身份校验确保身份没有异常

- https的ssl连接过程

- GET和POST的区别

    >get用于获取资源，post用于传输消息体主体，会修改服务器上的资源
    >
    >get没有消息体，参数放在URL中，post有消息体，参数放在主体中
    >
    >即get方法是幂等（多次请求的结果是一样的），post不是幂等的

#### 5.数据库登录注册相关

- 登录说一下？

    >1.载入数据表 2.提取用户名和密码3.注册和登录校验4.页面跳转
    >
    >1. 载入数据表就是把数据库的数据通过map容器上传至服务器
    >
    >2. 当浏览器上获得用户名和密码后，浏览器发送一个post请求报文，服务器通过解析请求报文的消息体，解析出账号密码
    >3. 根据解析出来的账号密码与map容器中保存的账号密码进行对比校验，相符则登陆成功；如果是注册，则对比用户名是否重复，不相同再加入
    >4. 当账号密码匹配成功后，则跳转至相应的页面

- 你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）

    >Cookie：
    >
    >HTTP/1.1引入cookie来保存状态信息，c**ookie是服务器发送到用户浏览器并保存在本地的一小块数据**，它会被浏览器再次请求服务器是被携带，用于告知服务器端两个请求是否来自同一浏览器
    >
    >Session：
    >
    >Cookie是将信息存储在客户端的浏览器中，**而Session是将信息存储在服务器端**。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。Session机制是一种服务器端机制，使用类似哈希表或者哈希表的结构来存储信息。
    >
    >总结：
    >
    >1. session存储在服务器端，cookie存储在客户端，相比而言，session更安全
    >2. cookie只能存储ASCII码字符串，session可以存储任何类型的数据
    >3. cookie不占用服务器，性能较高；反之，session占用服务器，性能较低

- 登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？

- 用的mysql啊，redis了解吗？用过吗？

    >1. mysql是关系型数据库，主要存放持久化数据，数据存放在硬盘，读取速度慢
    >2. redis是非关系型数据库，也是缓存数据库，即将数据存储在缓存中，读取速度快，但数据保存时间有限
    >
    >缓存：就是数据交换的缓冲区
    >
    >- 缓解服务器压力
    >- 缓存一般位于内存中，读取缓存的速度更快

#### 6.定时器相关

- 为什么要用定时器？
    
    - **为了方便释放那些超时的非活动连接，关闭被占用的文件描述符**
    
- 说一下定时器的工作原理

    >1.什么是定时事件
    >
    >是指固定一段时间之后触发某段代码，由该段代码处理一个事件。这里指的是删除epoll树上的注册事件，并关闭对应的Socket，连接次数减一
    >
    >2.什么是定时器
    >
    >定时器是指利用结构体或其他形式，**将多种定时事件进行封装**。本项目只涉及一种定时事件，这里将该定时事件与连接资源封装起来为一个定时器类。具体包括连接资源，超时时间，回调函数
    >
    >3.连接资源包括什么
    >
    >连接资源包括客户端套接字地址，文件描述符和定时器
    >
    >4.超时时间
    >
    >超时时间 = 浏览器和服务器连接时刻+固定时间，**是使用绝对时间作为超时值**
    >
    >5.什么是定时器容器
    >
    >本项目中采用升序的双链表作为定时容器，**具体的为每个连接创建一个定时器**，将其添加至链表中，并按照超时时间升序排列
    >
    >6.什么是定时任务
    >
    >将超时的定时器从链表中删除
    >
    >7.什么是定时任务处理函数
    >
    >定时任务处理函数，该函数封装在容器类中，具体是函数遍历升序链表容器，根据超时时间，删除对应的到期的定时器，并调用回调函数（即定时事件）
    >
    >定时器工作原理：
    >
    >服务器主循环为每一个连接创建一个定时器，并对每个连接定时。此外，使用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务处理函数
    >
    >如何通知主循环？
    >
    >利用alarm函数周期性的触发SIGALRM，信号处理函数利用管道通知循环（本项目将信号对应处理逻辑放在主循环中，由主循环执行信号对应的逻辑代码）

- 双向链表啊，删除和添加的时间复杂度说一下？还可以优化吗？

    >添加尾节点的复杂度与为O(n)，从头遍历新定时器在链表中的位置，如果位置恰好在最后，才插入在尾节点，删除节点的时间复杂度是O(1)，
    >
    >

- 最小堆优化？说一下时间复杂度和工作原理

#### 7.日志相关

- 说下你的日志系统的运行机制？

    >本日志系统采用了单例模式、循环数组实现的阻塞队列、同步和异步两种方式实现的日志系统
    >
    >首先判定是同步还是异步，在判断是否分件，然后再将数据写入日志系统

- 为什么要异步？和同步的区别是什么？

    >同步和异步主要区别是在于是否需要等待，本系统中同步日志写入函数需要和工作线程串行执行，需要等待工作线程完成之后才能执行；而异步则是自己创建一个写线程将信息写入至阻塞队列，不需要等待，效率更高

- 现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）

    >观察者模式，一个对象的状态发生改变，依赖的对象会随之自动更新发生相应变化
    >